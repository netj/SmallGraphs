<!DOCTYPE html>
<html xmlns:svg="http://www.w3.org/2000/svg">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>SmallGraphs</title>
    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="jquery-ui/js/jquery-1.6.2.min.js"></script>
    <script type="text/javascript" src="jquery-svg/jquery.svg.js"></script>
    <script type="text/javascript" src="jquery-svg/jquery.svgdom.js"></script>
    <script type="text/javascript" src="jquery-ui/js/jquery-ui-1.8.16.custom.min.js"></script>
    <style type="text/css">
      @import url("jquery-ui/css/cupertino/jquery-ui-1.8.16.custom.css");

      #query {
        width: 600px;
        height: 400px;
        border: 1px solid #ccc;
      }

      #query-type-entry {
        display: none;
      }
      #query-type-entry.active {
        display: block;
        position: absolute;
      }
      #query-type-entry input {
        opacity: 0.8;
        width: 65px;
        height: 25px;
      }
      #query-type-entry input, .ui-widget {
        font-size: 0.8em;
      }

      #query-sketchpad-selectionbox rect {
        fill-opacity: 0;
        stroke-opacity: 0;
      }
      #query-sketchpad-selectionbox.active rect {
        stroke-opacity: 0.75;
        stroke-dasharray: 3,3;
        stroke-width: 1px;
        stroke: #333;
      }

      #query-sketchpad-attribute-phantom-node rect {
        fill-opacity: 0;
        stroke-opacity: 0;
      }
      #query-sketchpad-attribute-phantom-node.active rect {
        stroke-opacity: 1;
        stroke-dasharray: 5,5;
        stroke-width: 2px;
        stroke: #ccc;
      }

      .node rect {
        fill: #c33;
        opacity: 0.9;
        stroke-width: 2px;
      }
      .node text,
      .edge text {
        text-anchor: middle;
      }

      #arrow-cap,
      .edge line {
        fill: #33c;
        stroke: #33c;
      }
      .edge line {
        opacity: 0.7;
        stroke-width: 7px;
        stroke-linecap: round;
        marker-end: url(#arrow-cap);
      }

      #query-sketchpad .node:hover rect { stroke: #900; }
      #query-sketchpad .edge:hover line { stroke: #009; }
      #query-sketchpad .node.selected:hover rect,
      #query-sketchpad .edge.selected:hover line { stroke: #090; }
      #query-sketchpad .node.selected       rect,
      #query-sketchpad .edge.selected       line { fill: #3c3; stroke: #3c3; }



      .result {
        display: inline-block;
        border: 1px solid #ccc;
        padding: 10px;
      }

      .result .node rect {
        fill: #eee;
        stroke-width: 1px;
      }
      .result .edge line {
        stroke-width: 1px;
      }
    </style>
  </head>

  <body>
    <h1>SmallGraphs</h1>
    <div id="query">
      <button id="query-run">Search Instances</button>
      <svg xmlns="http://www.w3.org/2000/svg" id="query-sketchpad">
        <g id="query-sketch"/>
        <marker id="arrow-cap"
          viewBox="0 0 10 10" refX="5" refY="5" 
          markerUnits="strokeWidth"
          markerWidth="4" markerHeight="3"
          orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 Z"/>
        </marker>
        <g id="query-sketchpad-selectionbox"><rect/><text/></g>
        <g id="query-sketchpad-attribute-phantom-node"><rect/><text/></g>
      </svg>
      <div id="query-type-entry" class="ui-widget">
        <input type="text" id="query-type-input">
      </div>
    </div>
    <div id="result">
    </div>

    <script type="text/javascript">
var SVGNameSpace = "http://www.w3.org/2000/svg";
var MouseMoveThreshold = 5;
var NodeWidth  = 40;//px
var NodeHeight = 20;//px
var NodeRounding = 5;//px
var EdgeMarkerSize = 11;//px

////////////////////////////////////////////////////////////////////////////////
// graph schema/ontology
var NodeTypes = [];
// retreive schema in advance, e.g. edge limiting allowed types of source/target nodes and vice versa
var GraphSchema;
$.getJSON("schema.json", function(schema) {
    GraphSchema = schema;
    NodeTypes = [];
    for (var objName in schema.Objects)
      NodeTypes.push(objName);
  });

////////////////////////////////////////////////////////////////////////////////

function createNode(x, y) {
  var node = addToSketchpad("g", {
      class: "node",
      transform: translate(x, y),
    });
  node.x = x;
  node.y = y;
  addToSketchpad("rect", {
      rx: NodeRounding ,      ry: NodeRounding,
      x: -NodeWidth   ,      y: -NodeHeight  ,
      width :  NodeWidth*2 , height:  NodeHeight*2,
    }, node);
  addToSketchpad("text", {
      dy: 5,
    }, node);
  return node;
}

function getNode(e) {
  if ($(e.parentNode).hasClass("node"))
    return e.parentNode;
  return null;
}
function getEdge(e) {
  if ($(e.parentNode).hasClass("edge"))
    return e.parentNode;
  return null;
}

function keySet(obj) {
  var keys = [];
  for (var key in obj)
    keys.push(key);
  return keys;
}

function removeAll(allElements, elementsToRemove) {
  if (!elementsToRemove || elementsToRemove.length == 0)
    return allElements;
  return allElements.filter(function(n) { return (elementsToRemove.indexOf(n) == -1) });
}

////////////////////////////////////////////////////////////////////////////////
// transforms, coordinates stuff

function translate(x,y) {
  return "translate("+ x +","+ y +")";
}

function pathbox(x1,y1, x2,y2) {
  return "M"+x1+" "+y1+" "+
         "L"+x2+" "+y1+" "+
         "L"+x2+" "+y2+" "+
         "L"+x1+" "+y2+" "+
         "Z";
}

function updateEdgeCoordinates(e, x2, y2, line, label, dangling) {
    var r = Math.sqrt(x2*x2 + y2*y2);
    var x1 = r < NodeWidth  ? 0 : NodeWidth  * x2/r;
    var y1 = r < NodeHeight ? 0 : NodeHeight * y2/r;
    var dx = x2/r * EdgeMarkerSize;
    var dy = y2/r * EdgeMarkerSize;
    (line || $("line", e)).attr({
        x1: x1, y1: y1,
        x2: x2 -dx -(dangling?0:x1), y2: y2 -dy -(dangling?0:y1),
      });
    (label || $("text", e)).attr({ x : x2 / 2, y : y2 / 2 });
}

////////////////////////////////////////////////////////////////////////////////
// sketchpad
var sketchpad = $("#query-sketchpad")[0];
var sketchpadDoc = sketchpad.ownerDocument;
var sketchpadSelectionBox = $("#query-sketchpad-selectionbox")[0];
var sketchpadAttributePhantomNode = $("#query-sketchpad-attribute-phantom-node")[0];
$(sketchpad).bind("selectstart", function() { event.preventDefault(); });
var sketch = $("#query-sketch")[0];

function addToSketchpad(name, attrs, target) {
  var node = sketchpadDoc.createElementNS(SVGNameSpace, name);
  $(node).attr(attrs);
  (target || sketch).appendChild(node);
  return node;
}

var queryTypeEntryHandler = null;
$("#query-type-input")
  .keyup(function() {
      switch (event.keyCode) {
        case 27: // esc
          this.value = "";
          break;
        case 14: // enter
        case 13: // return
          break;
        default:
          return;
      }
      this.blur();
    })
  .blur(function() {
      if (queryTypeEntryHandler)
        queryTypeEntryHandler(this.value);
      queryTypeEntryHandler = null;
      $("#query-type-entry").removeClass("active");
    })
  ;

function queryTypeEntryShow(x, y, list, done) {
  if (queryTypeEntryHandler)
    queryTypeEntryHandler();
  queryTypeEntryHandler = done;
  $("#query-type-input").autocomplete({
      delay: 0,
      minLength: 0,
      source: list,
    });
  $("#query-type-entry")
    .css({
        left: x,
        top:  y,
      })
    .addClass("active")
    ;
  var input = $("#query-type-input")[0];
  if (list.length == 1)
    input.value = list[0];
  else if (list.indexOf(input.value) < 0)
    input.value = "";
  setTimeout(function() {
      input.focus();
      input.select();
    }, 1);
}

////////////////////////////////////////////////////////////////////////////////
var sketchpadActions = [];

sketchpadActions.push({
  name: "add node",
  modifierKeys: ["alt"],
  click: function() {
    if (event.target == sketchpad) {
      // create node
      var node = createNode(event.offsetX, event.offsetY);
      // ask user to choose type
      queryTypeEntryShow(
          sketchpad.offsetLeft + event.offsetX -NodeWidth +5,
          sketchpad.offsetTop  + event.offsetY -NodeHeight+5,
          NodeTypes, function(type) {
            if (type) {
              node.objectType = type;
              $("text", node).text(type);
              console.log("added node", type, node);
            } else {
              // cancel node creation
              $(node).remove();
            }
          });
      return false;
    }
  },
});

sketchpadActions.push({
  name: "move node",
  mousedown: function() {
    // TODO move all selected nodes
    var n = getNode(event.target);
    if (n) {
      this.node = n;
      this.offsetX = event.offsetX - parseInt(n.x);
      this.offsetY = event.offsetY - parseInt(n.y);
      var starting = [];
      var ending = [];
      $(".edge", sketchpad).each(function(i, e) {
          if (e.source == n) {
            starting.push(e);
          } else if (e.target == n) {
            ending.push(e);
          }
        });
      this.edgesStarting = starting;
      this.edgesEnding = ending;
      return this;
    }
  },
  mousemove: function() {
    var x = event.pageX - sketchpad.offsetLeft - this.offsetX;
    var y = event.pageY - sketchpad.offsetTop  - this.offsetY;
    this.node.x = x;
    this.node.y = y;
    $(this.node).attr({
      transform: translate(x, y),
    });
    // move edges together
    this.edgesStarting.forEach(function(e) {
        $(e).attr({ transform: translate(x,y) });
        var x2 = e.target.x - x;
        var y2 = e.target.y - y;
        updateEdgeCoordinates(e, x2, y2);
      });
    this.edgesEnding.forEach(function(e) {
        var x2 = x - e.source.x;
        var y2 = y - e.source.y;
        updateEdgeCoordinates(e, x2, y2);
      });
  },
});

sketchpadActions.push({
  name: "draw edge from a node",
  modifierKeys: ["alt"],
  mousedown: function() {
    var n = getNode(event.target);
    if (n) {
      if (n.isAttributeNode) // preventing edges being created from attribute nodes
        return null;
      // create edge
      this.sx = parseInt(n.x);
      this.sy = parseInt(n.y);
      var e = this.edge = addToSketchpad("g", {
          class: "edge",
          transform: translate(this.sx, this.sy),
        });
      e.source = n;
      e.target = null;
      this.line = $(addToSketchpad("line", {
          x1: 0, y1: 0,
          x2: 0, y2: 0,
        }, e));
      this.label = $(addToSketchpad("text", {
          dy: 20,
        }, e));
      // prepare related schema for this source node
      this.objectSchema = GraphSchema.Objects[n.objectType];
      var targetObjects = [];
      for (var l in this.objectSchema.Links)
        targetObjects = targetObjects.concat(this.objectSchema.Links[l]);
      this.allowedTargetObjectTypes = targetObjects;
      return this;
    }
  },
  mousemove: function() {
    // drawing edge
    var tx = event.offsetX;
    var ty = event.offsetY;
    var n = getNode(event.target);
    if (n) {
      if (n == this.edge.source) { // disallowing self/reflexive/recursive edges
        n = null; 
      } else if (n.isAttributeNode) { // preventing edges being created to existing attribute nodes
        n = null;
      }
    }
    if (n) { // pointing on a node
      // hide phantom attribute node
      $(sketchpadAttributePhantomNode).removeClass("active");
      $("rect", sketchpadAttributePhantomNode).attr({ width : 0, height: 0 });
      // attract end of edge to the node
      tx = n.x;
      ty = n.y;
      // check graph schema
      var targetObjectType = n.objectType;
      var allowedEdgeTypes = [];
      var objectsByLinks = this.objectSchema.Links;
      for (var l in objectsByLinks)
        if (objectsByLinks[l].indexOf(targetObjectType) != -1)
          allowedEdgeTypes.push(l);
      this.allowedEdgeTypes = allowedEdgeTypes;
      // TODO highlight tentative target node
      // TODO show edge is invalid
    } else { // not pointing on a node
      // show phantom attribute node
      $(sketchpadAttributePhantomNode).addClass("active");
      $("rect", sketchpadAttributePhantomNode)
        .attr({
            x: tx+10, // FIXME displace this phantom node
            y: ty+10,
            width : NodeWidth,
            height: NodeHeight,
          })
        ;
    }
    var x2 = tx - this.sx;
    var y2 = ty - this.sy;
    updateEdgeCoordinates(null, x2, y2, this.line, this.label, n==null);
  },
  mouseup: function() {
    var n = getNode(event.target);
    if (n == this.edge.source) { // disallowing self/reflexive/recursive edges
      // cancel edge
      $(this.edge).remove();
    } else if (n) { // finish edge
      var e = this.edge;
      e.target = n;
      // ask user to choose type
      queryTypeEntryShow(
          sketchpad.offsetLeft + this.sx + parseInt(this.label.attr("x")),
          sketchpad.offsetTop  + this.sy + parseInt(this.label.attr("y")),
          this.allowedEdgeTypes,
          function(type) {
            if (type) {
              e.linkType = type;
              $("text", e).text(type);
              console.log("added edge", type, e);
            } else {
              // cancel edge creation
              $(e).remove();
            }
          });
    } else { // add attribute and an edge to it
      var e = this.edge;
      queryTypeEntryShow(
          sketchpad.offsetLeft + this.sx + parseInt(this.label.attr("x")),
          sketchpad.offsetTop  + this.sy + parseInt(this.label.attr("y")),
          keySet(this.objectSchema.Attributes),
          function(type) {
            if (type) {
              // TODO add attribute node
              //e.target = n;
              e.linkType = type;
              $("text", e).text(type);
              console.log("added attribute edge", type, e);
            } else {
              // cancel edge creation
              $(e).remove();
            }
          });
    }
  },
});

var sketchpadCurrentSelection = [];
sketchpadActions.push({
  name: "select node or edge",
  click: function() {
    var nodeOrEdge = getNode(event.target) || getEdge(event.target);
    if (nodeOrEdge) {
      var isDoingMultipleSelection = event.metaKey || event.ctrlKey;
      if (isDoingMultipleSelection) {
        if ($(nodeOrEdge).hasClass("selected")) {
          removeAll(sketchpadCurrentSelection, [nodeOrEdge]);
          $(nodeOrEdge).removeClass("selected");
        } else {
          $(nodeOrEdge).addClass("selected");
          sketchpadCurrentSelection.push(nodeOrEdge);
        }
      } else {
        $(sketchpadCurrentSelection).removeClass("selected");
        sketchpadCurrentSelection = [];
        $(nodeOrEdge).addClass("selected");
        sketchpadCurrentSelection.push(nodeOrEdge);
        // TODO when selecting an edge, we should immediately do something?
      }
    }
    return false;
  },
});

sketchpadActions.push({
  name: "select area",
  mousedown: function() {
    if (event.target == sketchpad) {
      var x1 = this.x1 = event.offsetX;
      var y1 = this.y1 = event.offsetY;
      this.rect = $("rect", sketchpadSelectionBox)
        .attr({ x: x1, y: y1, width: 0, height: 0 });
      $(sketchpadSelectionBox).addClass("active");
      // TODO invert selection? or exclude range from current selection?
      // incremental selection
      var isDoingMultipleSelection = event.metaKey || event.ctrlKey;
      if (isDoingMultipleSelection) {
        this.initialSelection = sketchpadCurrentSelection;
      } else {
        $(sketchpadCurrentSelection).removeClass("selected");
        sketchpadCurrentSelection = this.initialSelection = [];
      }
      this.lastNodesInBox = [];
      return this;
    }
    // TODO index nodes by coordinates (linear search might be better for mere set of small number of nodes)
  },
  mousemove: function() {
    var x1 = this.x1;
    var y1 = this.y1;
    var x2 = event.pageX - sketchpad.offsetLeft;
    var y2 = event.pageY - sketchpad.offsetTop ;
    this.rect.attr({
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width:  Math.abs(x2 - x1),
        height: Math.abs(y2 - y1),
      });
    // update selection
    var xl = Math.min(x1,x2);
    var xu = Math.max(x1,x2);
    var yl = Math.min(y1,y2);
    var yu = Math.max(y1,y2);
    var nodesInBox = $(".node", sketchpad)
      .filter(function(i) {
          var x = this.x;
          var y = this.y;
          return (xl <= x && x <= xu &&
                  yl <= y && y <= yu);
        })
      .addClass("selected")
      .toArray()
      ;
    var nodesOutOfBoxNow = removeAll(this.lastNodesInBox, nodesInBox.concat(this.initialSelection));
    $(nodesOutOfBoxNow).removeClass("selected");
    //console.debug(nodesInBox.length, nodesOutOfBoxNow.length);
    this.lastNodesInBox = nodesInBox;
    sketchpadCurrentSelection = this.initialSelection.concat(nodesInBox);
  },
  mouseup: function() {
    $(sketchpadSelectionBox).removeClass("active");
    this.rect.attr({ width: 0, height: 0 });
  }
});

sketchpadActions.push({
  name: "remove selection",
  forKeys: [
    8,  // DOM_VK_BACK_SPACE
    46, // DOM_VK_DELETE
  ],
  keypress: function() {
    // first, remove edges that will become dangling by removing the selection
    $(".edge", sketchpad).filter(function() {
        return (sketchpadCurrentSelection.indexOf(this.source) >= 0 ||
                sketchpadCurrentSelection.indexOf(this.target) >= 0);
      }).remove();
    // then, remove the selection
    $(sketchpadCurrentSelection).remove();
    sketchpadCurrentSelection = [];
  },
});


sketchpadActions.push({
  name: "add aggregation",
  // TODO
});

sketchpadActions.push({
  name: "add constraints",
  // TODO
});

////////////////////////////////////////////////////////////////////////////////
// sketchpad action dispatcher
////////////////////////////////////////////////////////////////////////////////
// See for keycodes: https://developer.mozilla.org/en/DOM/KeyboardEvent#Virtual_key_codes
// TODO build an index of actions for each event
var sketchpadCurrentMouseActions = [];
var sketchpadFirstMouseEvent = null;
function SketchpadAction(def) {
  // FIXME there must be a better way than copying contents of actionDef
  for (var i in def)
    this[i] = def[i];
}
var ModifierKeys = ["shift", "alt", "ctrl", "meta"];
function sketchpadActionDefSatisfyModifierKey(actionDef) {
  if (actionDef.modifierKeys) {
    var keyIsOn = function(modifier){ return event[modifier+"Key"]; }
    if (!(actionDef.modifierKeys.every(keyIsOn) &&
          !removeAll(ModifierKeys, actionDef.modifierKeys).some(keyIsOn)))
      return false;
  } else {
    if (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey)
      return false;
  }
  return true;
}
function sketchpadMouseDown() {
  sketchpadFirstMouseEvent = event;
  sketchpadActions.forEach(function(actionDef) {
      if (actionDef.mousedown) {
        if (!sketchpadActionDefSatisfyModifierKey(actionDef)) return;
        try {
          var a = new SketchpadAction(actionDef);
          var r = a.mousedown();
          if (r != null) {
            console.log(event.type, event, a, a.name);
            if (r) sketchpadCurrentMouseActions.push(a);
          }
        } catch (err) {
          console.error(err, err+"");
        }
      }
  });
}
function sketchpadMouseMove() {
  sketchpadCurrentMouseActions.forEach(function(a) {
    try {
      if (a.mousemove) {
        console.log(event.type, event, a, a.name);
        a.mousemove();
      }
    } catch (err) {
      console.error(err, err+"");
    }
  });
}
function sketchpadMouseUp() {
  sketchpadCurrentMouseActions.forEach(function(a) {
    try {
      if (a.mouseup) {
        console.log(event.type, event, a, a.name);
        a.mouseup();
      }
    } catch (err) {
      console.error(err, err+"");
    }
  });
  sketchpadCurrentMouseActions = [];
  // process clicks if were not dragging
  if (Math.abs(event.pageX-sketchpadFirstMouseEvent.pageX) < MouseMoveThreshold &&
      Math.abs(event.pageY-sketchpadFirstMouseEvent.pageY) < MouseMoveThreshold) {
    sketchpadActions.forEach(function(actionDef) {
      if (actionDef.click) {
        if (!sketchpadActionDefSatisfyModifierKey(actionDef)) return;
        try {
          var a = new SketchpadAction(actionDef);
          console.log("click", event, a, a.name);
          a.click();
        } catch (err) {
          console.error(err, err+"");
        }
      }
    });
  }
  // TODO double clicks?
}

var sketchpadCurrentKeyActions = [];
function sketchpadKeyDown() {
  sketchpadFirstMouseEvent = event;
  sketchpadActions.forEach(function(actionDef) {
    if (actionDef.forKeys && actionDef.forKeys.indexOf(event.keyCode) != -1) {
      if (actionDef.keydown) {
        try {
          var a = new SketchpadAction(actionDef);
          var r = a.keydown();
          if (r != null) {
            console.log(event.type, event, a, a.name);
            if (r) sketchpadCurrentKeyActions.push(a);
          }
        } catch (err) {
          console.error(err, err+"");
        }
      }
    }
  });
}
function sketchpadKeyUp() {
  sketchpadCurrentKeyActions.forEach(function(a) {
    try {
      if (a.keyup) {
        console.log(event.type, event, a, a.name);
        a.keyup();
      }
    } catch (err) {
      console.error(err, err+"");
    }
  });
  sketchpadCurrentKeyActions = [];
  // process keypresses TODO if were not repeating?
  // if (true) {
    sketchpadActions.forEach(function(actionDef) {
      if (actionDef.keypress && actionDef.forKeys && actionDef.forKeys.indexOf(event.keyCode) != -1) {
        try {
          var a = new SketchpadAction(actionDef);
          console.log("keypress", event, a, a.name);
          a.keypress();
        } catch (err) {
          console.error(err, err+"");
        }
      }
    });
  // }
}
$(sketchpad)
  .bind("mousedown", sketchpadMouseDown)
  ;
$(window)
  .bind("mousemove", sketchpadMouseMove)
  .bind("mouseup",   sketchpadMouseUp)
  .bind("keydown",   sketchpadKeyDown)
  .bind("keyup",     sketchpadKeyUp)
  ;
    </script>

    <script type="text/javascript">

var results = $("#result");

function smallgraphsRunQuery() {
  // TODO formulate/serialize query from sketch
  // TODO send it to server and get response
  // TODO show each subgraph instance as small multiples
  showResults(null);
}

var resultScale = 0.33;
function showResults(data) {
  $(".result", results).remove();
  // dynamically determine the bounding box of sketch and use that as the size for each
  var sketchWidth  = sketchpad.offsetWidth;
  var sketchHeight = sketchpad.offsetHeight;
  var firstNode = $(".node", sketch)[0];
  var minX, maxX; minX = maxX = firstNode.x;
  var minY, maxY; minY = maxY = firstNode.y;
  $(".node", sketch).each(function(i,n){
      minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
      minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
    });
  sketchWidth  = maxX - minX + 2*NodeWidth;
  sketchHeight = maxY - minY + 2*NodeHeight;
  var translateX = - minX + NodeWidth;
  var translateY = - minY + NodeHeight;
  var resultWidth  = resultScale * sketchWidth;
  var resultHeight = resultScale * sketchHeight;
  // build a prototype for individual result
  // TODO adjust edge coords, or add an arrow-ending?
  var resultPrototype = $(sketch)
    .clone()
    .removeAttr("id")
    .attr({
        transform: "scale("+ resultScale +"), translate("+ translateX +","+ translateY +")",
      })
    ;
  $(".edge text", resultPrototype)
    .remove()
    ;
  // now, show each of them
  for (var i=0; i<100; i++) {
    var aResultSVG = document.createElementNS(SVGNameSpace, "svg");
    resultPrototype
      .clone()
      .appendTo(aResultSVG)
      ;
    // TODO fill data
    $("<div>")
      .attr({
          class: "result",
        })
      .css({
          width : resultWidth +"px",
          height: resultHeight+"px",
        })
      .append(aResultSVG)
      .appendTo(results)
      ;
  }
}

$("#query-run").click(smallgraphsRunQuery);
    </script>
  </body>
</html>
<!--
vim:sw=2:sts=2
-->
