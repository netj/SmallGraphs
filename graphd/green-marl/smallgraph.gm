// SmallGraph query matcher in Green-Marl (w/ C++ backend)
// Author: Jaeho Shin <netj@cs.stanford.edu>
// Created: 2012-01-27

// Assumption:
//    Green-Marl   vs      C++
// --------------------------------------
// - Bag<$UDT>     == list<$UDT *> *
// - EmptyBag()    == new list<...>()
// - bag.IsEmpty() == (bag->size() == 0)

Proc FindMatches(
            g: Graph,
            nodeType: Node_Prop<$type_t>(g),
            edgeType: Edge_Prop<$type_t>(g),
            q: $SmallGraphQuery,
            currentMatches: Node_Prop<Bag<$Match>>(g),
            nextMatches: Node_Prop<Bag<$Match>>(g)
        ): Bag<$Match> {
    // initialize matching states
    Foreach (Node(g) n: g.Nodes) {
        n.currentMatches = InitialMatches();
        n.nextMatches = EmptyBag();
    }

    // exhaustive extension of matches
    Bool changed;
    Do {
        changed = False;
        Foreach (Node(g) n: g.Nodes) (! n.currentMatches.IsEmpty()) {
            // try matching this node
            Bag<$Match> ms = ExtendNodeFromMatches(q, n.currentMatches, n, n.nodeType);
            If (! ms.IsEmpty()) {
                For (Edge(e) e: n.OutEdges) {
                    // try matching each outgoing edge
                    Bag<$Match> ms2 = ExtendEdgeFromMatches(q, ms, e, e.edgeType);
                    If (! ms2.IsEmpty()) {
                        // and pass the matching state to the neighbor node
                        n2 = e.TargetNode; // XXX unavailable in GreenMarl?
                        n2.nextMatches.Append(ms2); // TODO n2.nextMatches += ms2;
                        changed = True;
                    }
                }
            }
        }
        // shift next match to current
        For (Node(g) n: g.Nodes) {
            n.currentMatches = n.nextMatches;
            n.nextMatches = EmptyBag();
        }
    } While (changed == True);

    // collect matching subgraphs
    Bag<$Match> matchingSubgraphs = EmptyBag();
    Foreach (Node(g) n: g.Nodes) {
        For ($Match m: n.currentMatches) (IsCompleteMatch(m)) {
            matchingSubgraphs.Add(m);
        }
    }

    Return matchingSubgraphs;
}

Local InitialMatches(q: $SmallGraphQuery): Bag<$Match> {
    Bag<$Match> ms = EmptyBag();
    ms.Add([new Match($q)]);
    Return ms;
}

Local ExtendNodeFromMatches(
            g: Graph,
            q: $SmallGraphQuery,
            matches: Bag<$Match>,
            n: Node(g),
            nType: $type_t
        ): Bag<$Match> {
    // XXX assuming (Bag<$Match> == list<Match *> *) in C++
    [ list<Match *> *newMatches = new list<Match *>(); ]
    For ($Match m: matches) {
        [ $m->extendWithNode($nType, $n, newMatches); ]
    }
    Return [newMatches];
}

Local ExtendEdgeFromMatches(
            g: Graph,
            q: $SmallGraphQuery,
            matches: Bag<$Match>,
            e: Edge(g),
            eType: $type_t
        ): Bag<$Match> {
    // XXX assuming (Bag<$Match> == list<Match *> *) in C++
    [ list<Match *> *newMatches = new list<Match *>(); ]
    For ($Match m: matches) {
        [ $m->extendWithEdge($eType, $e, newMatches); ]
    }
    Return [newMatches];
}

Local IsCompleteMatch(match: $Match): Bool {
    Return [match->isComplete()];
}
